
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas width="1000" height="1000"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.round(x)
    y = Math.round(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * 你的任务：通过调用dot函数，实现：
   * 需要注意，dot函数不能接收浮点数，如果参数为浮点数，会被转换为整数后绘制
      * 在 坐标 (42, 42) 画出一个点
      * 画一条水平实线，粗细为一个像素
      * 画一条垂直实线，粗细为一个像素
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴的夹角呈30度）
      * 画一条60度的斜线（与x轴的夹角呈60度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个空心的圆，圆心在画布中心：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小位置都合适】的sin(x)的图像
      * 画一个贝塞尔曲线（二阶或三阶均可，二阶由三个点确定，三阶由四个点确定）

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
      * 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里

  //在 坐标 (42, 42) 画出一个点
  dot(42,42)
  //画一条水平实线，粗细为一个像素
  for(var x = 20 ; x < 200 ; x++) {
    dot(x , 20 , "red")
  }
  
  // 画一条垂直实线，粗细为一个像素
  for(var y = 0 ; y < 200 ; y++) {
    dot(20 , y)
  }

  //画一条一个实点一个空点的虚线
  for(var x = 200 ; x < 450 ; x += 2) {
    dot(x , 30)
  }
   // 画一条两个实点两个空点的虚线
  for(var x = 200 ; x < 450 ; x++) {
    if(x % 4 < 2)
      dot(x , 40)
  }

  // 画一条三个实点两个空点的虚线
  for(var x = 200 ; x < 450 ; x++) {
    if(x % 5 < 3)
      dot(x , 50)
  }
  // 45deg
  function line6(x1 , y1 ,x2 ,y2) {
    for(var i = x1 ; i <= x2 ; i++) {
      dot(i , i)
    }
  }
  line6(0 , 0 , 60 , 60)
 
  // 30deg
  for(var x = 0 ; x < 200 ; x++) {
    dot(x , x / Math.sqrt(3))
  }

  // 60deg
  for(var y = 0 ; y < 200 ; y++) {
    dot( y / Math.sqrt(3) , y)
  }

  // 任意一个矩形的对角线函数
  // 我的版本
  //当斜率 k 的绝对值大于 0.5（|k| > 0.5），直线更靠近 y 轴，像陡坡，变化主要在 y 方向。所以循环 y（y 从 y1 到 y2），用 y 通过直线方程算 x（x = x1 + (y - y1) / k），确保点连续。
  //当斜率 k 的绝对值小于 0.5（|k| < 0.5），直线更靠近 x 轴，像平路，变化主要在 x 方向。所以循环 x（x 从 x1 到 x2），用 x 通过直线方程算 y（y = y1 + k * (x - x1)），保证点均匀。
  function diagonalLine(x1 , y1 , x2 , y2) {
    var k = (y2 - y1) / (x2 - x1) // 斜率的计算公式（tanx = sinx / cosx）
    if(k <= 0.5) {
      for(var x = x1 ; x <= x2 ; x++) {
        dot(x , x * k)
      }
    }
    else {
      for(var y = y1 ; y <= y2 ; y++) {
        dot(y / k , y)
      }
    }
  }
  

  //老师的版本1(相比起我的写法，不用循环计算乘除法而是计算加减法，速度更快，核心在于如果偏y轴，那么y+1，x就加k，反之亦然。)
  function diagonalLine1(x1 , y1 , x2 , y2) {
    var k = (y2 - y1) / (x2 - x1) // 斜率的计算公式（k = tan = sin / cos）
    if(k <= 0.5) {
      for(var x = x1 , y = y1 ; x <= x2 ; x++ , y += k ) {
        dot(x , y)
      }
    }
    else {
      for(var y = y1 , x = x1 ; y <= y2 ; y++ , x += 1 / k) {
        dot(x , y)
      }
    }
  }
  
  // 老师的版本2（相比起老师的第一个版本较少了浮点运算，底层逻辑是等比例放大x每次加的数和y每次加的数来取整，这是一个计算机图形学的问题，并不容易搞懂）
  function diagonalLine2(x1 , y1 , x2 , y2) {
    var dx = x2 - x1 // x方向的跨度
    var dy = y2 - y1 // y方向的跨度
    var y0 = 0
    for(var x = x1 , y = y1 ; x <= x2 ; x++) {
      dot(x , y)
      y0 += dy
      if(y0 > dx) {
        y++
        y0 -= dx
      }
    }
  }
  diagonalLine2(0 , 0 , 60 , 40)
  

  function outlinedRectangle(x , y , h , w) {
    for(var i = 0 ; i < w ; i++) {
      dot(x + i , y)
      dot(x + i , y + h)
    }
    for(var j = 0 ; j < h ; j++) {
      dot(x , y + j)
      dot(x + w , y + j)
    }
  }
  outlinedRectangle(400 , 200 , 100 ,100)
  
  function filledRectangle(x , y , h , w) {
    for(var a = 0 ; a < h ; a++) {
      for(var i = 0 ; i < w ; i++) {
        dot(x + i , y + a)
      }
    }
    for(var b = 0 ; b < w ; b++) {
      for (var j = 0 ; j < h ; j++) {
        dot(x + b , y + j)
      }
    }
  }
  filledRectangle(600 , 200 , 100 , 100)

  // 画半径分别为50和200的空心的圆
  // 我的暴力解法(思路是套公式然后把循环次数拉大，极其暴力极其不优雅且计算量大)
  function outlinedRound(x , y , r) {
    for(var i = 0 ; i < 720 ; i++) {
      dot(x + r * Math.cos(i) , y + r * Math.sin(i))
    }
  }
  // function outlinedRoundb(x , y , r) {
  //   for(var i = 0 ; i < 72000 ; i++) {
  //     dot(x + r * Math.cos(i) , y + r * Math.sin(i))
  //   }
  // }
  // outlinedRound(500 , 500 , 50)
  // outlinedRoundb(500 , 500 , 200)
  //老师的解法1（通过计算并画出1/8圆然后推导剩下的部分）
  // function outlinedRound(cx , cy , r) {
  //   for(var x = 0 ; x <= r / Math.sqrt(2) ; x++) {
  //     var y = Math.sqrt(r * r - x * x)
  //     dot(x +cx, y + cy)
  //     dot(- x +cx, y + cy)
  //     dot(x +cx, - y + cy)
  //     dot(- x +cx, - y + cy)
  //     dot(y +cx, x + cy)
  //     dot(- y +cx, x + cy)
  //     dot(y +cx, - x + cy)
  //     dot(- y +cx, - x + cy)
  //   }
  // }
  // outlinedRound(500 , 500 , 50)
  // outlinedRound(500 , 500 , 200)

  // 老师的解法2(和解法1相比没有了每次循环需要做的根号运算，更省时间省算力)
  //（假设从圆的最高点往第一象限开始画，终点是45deg的时候。每次画下一个点的时候要么在上一个点的右边要么在右下角，根据哪个点更接近r来选择。
  // 由此我们可以写出程序实现这一点然后通过1/8圆的思路让它在另外七个不同的起点上同时开始画。）
  function outlinedRound(cx , cy , r) {
    var x = 0
    var y = r
    while(x <= y) { //1/8的圆点分界线刚好在45deg角也就是x = y这条线上
      dot(x + cx , y + cy)
      dot(- x + cx , y + cy)
      dot(x + cx , - y + cy)
      dot(- x + cx , - y + cy)
      dot(y + cx, x + cy)
      dot(- y + cx, x + cy)
      dot(y + cx, - x + cy)
      dot(- y + cx, - x + cy)
      x++
      var y1 = y
      var y2 = y - 1
      var rr = r * r
      var r1 = y1 * y1 + x * x
      var r2 = y2 * y2 + x * x
      var d1 = Math.abs(rr - r1)
      var d2 = Math.abs(rr - r2)
      if( d1 < d2)
        y = y1
      else
        y = y2
    }
  }
  outlinedRound(500 , 500 , 50)
  outlinedRound(500 , 500 , 200)

  
  
  function filledRound(x , y , r) {
    var c = r
    for(var i = 0; i < c ; i++) {
      r--
      for(var j = 0 ; j < 720 ; j++) {
        dot(x + r * Math.cos(j) , y + r * Math.sin(j))
      }
    }
  }
  filledRound(100 , 500 , 100)

  // 画一个【大小位置都合适】的sin(x)的图像
  for(var x = 0 ; x < 1000 ; x++) {
    var y = 50 * Math.sin(x / 50)
    dot(x , y + 200)
  }
  // 画出rgb色彩空间的某一面（尺寸要大于100x100）
  for(var r = 0 ; r < 256 ; r++) {
    for(var g = 0 ; g < 256 ; g++) {
      var color = "rgb(" + r + "," + g + ",255)"
      dot(r , g + 745 , color)
    }
  }

  // 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
  // 可以考虑如下几种矩阵：
  //          2 0
  //          0 2
  for(var r = 0 ; r < 256 ; r++) {
    for(var g = 0 ; g < 256 ; g++) {
      var color = "rgb(" + r + "," + g + ",255)"
      var x = r * 2 //(分别是r的值为r和g分别乘以第一列对应的值再相加, g的值为r和g分别乘以第二列对应的值再相加)
      var y = g * 2
      dot(x + 255, y + 500 , color) // 因为放大了，在原本每个点的位置的右、下、右下一个单位的地方都有空缺，所以要在对应位置补画点
      dot(x + 256, y + 500 , color)
      dot(x + 255, y + 501 , color)
      dot(x + 256, y + 501 , color)
    }
  }
  
  //          1  0.27
  //          0  1
  for(var r = 0 ; r < 256 ; r++) {
    for(var g = 0 ; g < 256 ; g++) {
      var color = "rgb(" + r + "," + g + ",255)"
      var x = r 
      var y = g + 0.27 * r
      dot(x, y + 100 , color) 
    }
  }
  
  //          0.5    0.87
  //          -0.87  0.5
  for(var r = 0 ; r < 256 ; r++) {
    for(var g = 0 ; g < 256 ; g++) {
      var color = "rgb(" + r + "," + g + ",255)"
      var x = r * 0.5 - g * 0.87
      var y = g * 0.5 + 0.87 * r
      dot(x + 700 , y + 300 , color) 
    }
  }
//像素无损的旋转，公式出自网站：https://gautamnagrawal.medium.com/rotating-image-by-any-angle-shear-transformation-using-only-numpy-d28d16eb5076
  for(var r = 0 ; r < 256 ; r++) {
    var seta = 0.3
    for(var g = 0 ; g < 256 ; g++) {
      var color = "rgb(" + r + "," + g + ",255)"
      var x = r
      var y = g
      var
      //第一次运算(每一次运算结果都要取整，不然因为浮点数的问题会导致有空缺的点就是像素有损)
      x = Math.round(x)
      y = Math.round(y - Math.tan(seta / 2) * x)
      //第二次运算
      x = Math.round(x + Math.sin(seta) * y)
      y = Math.round(y)
      //第三次运算
      x = Math.round(x)
      y = Math.round(y - Math.tan(seta / 2) * x)
      dot(x + 700 , y + 300 , color)
    }
  }

  // 画一个贝塞尔曲线（二阶或三阶均可，二阶由三个点确定，三阶由四个点确定）
  // 关键点在线性插值，说直白点举个例子：(10 , 0),(110 , 0)这两个点连成一条线。从左往右在这条线的12%的位置的横坐标的值等于10 * 0.88 + 110 * 0.12
  function bezierCurve(x1 , y1 , x2 , y2 , x3 , y3) {
    for(var p  = 0 ; p <= 1 ; p += 0.001) {
      var x12 = x1 * (1 - p) + x2 * p
      var y12 = y1 * (1 - p) + y2 * p
      var x23 = x2 * (1 - p) + x3 * p
      var y23 = y2 * (1 - p) + y3 * p
      var x = x12 * (1 - p) + x23 * p
      var y = y12 * (1 - p) + y23 * p
      dot(x , y)
    }
  }
  bezierCurve(200,200,600,500,200,600)
</script>
</html>
